#include "ShaderTools/DefaultRenderLoop.h"
#include "ShaderTools/RenderPass.h"
#include "ShaderTools/VertexArrayObjects/Pyramid.h"
#include "ShaderTools/VertexArrayObjects/Skybox.h"
#include "ShaderTools/VertexArrayObjects/Plane.h"
#include "WarppingGame/CubemapTexture/CubemapTexture.h"

auto sp = new ShaderProgram({"/Test_ShaderTools/test.vert", "/Test_ShaderTools/test.frag"});
auto sp1 = new ShaderProgram({"/Warpping/myTest.vert", "/Warpping/myTest.frag"});
auto spSky = new ShaderProgram({"/Warpping/Skybox.vert", "/Warpping/Skybox.frag"});

auto pass = new RenderPass(
    new Plane(), 
    sp
);

auto sky = new RenderPass(
    new Skybox(), 
    spSky
);

auto passPyramide = new RenderPass(
    new Pyramid(), 
    sp
);

CubemapTexture* cubeText = new CubemapTexture();
GLuint test = cubeText->create_cube_map("/home/ivanna/git_repo/OpenGL_Framework/resources/skybox/jajlands1_rt.jpg",
    "/home/ivanna/git_repo/OpenGL_Framework/resources/skybox/jajlands1_lf.jpg",
    "/home/ivanna/git_repo/OpenGL_Framework/resources/skybox/jajlands1_up.jpg",
    "/home/ivanna/git_repo/OpenGL_Framework/resources/skybox/jajlands1_dn.jpg",
    "/home/ivanna/git_repo/OpenGL_Framework/resources/skybox/jajlands1_bk.jpg",
    "/home/ivanna/git_repo/OpenGL_Framework/resources/skybox/jajlands1_ft.jpg"    
 );

float size = 0.5;
float lum = 0.5;
float z=50.0;
float x=0.0;


glm::mat4 projMat = glm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.0f);
glm::mat4 model= glm::translate(glm::mat4(1.0), glm::vec3(0,0,0));


int main(int argc, char *argv[]) {
    sp -> printUniformInfo();
    sp -> printInputInfo();
    sp -> printOutputInfo();

    renderLoop([]{

        glm::mat4 viewMat       = glm::lookAt(   glm::vec3(x,1,z), // Camera is at (0,10,10), in World Space
                                         glm::vec3(0,0,0), // and looks at the origin
                                         glm::vec3(0,1,0));  // Head is up (set to 0, 1 ,0 to look upside-down)


     glm::mat4 modelPyramide= glm::scale(glm::mat4(1),glm::vec3(5,20,5));


     glm::mat4 sky = glm::scale(glm::mat4(1), glm::vec3(10,10,10));
 
  // modelPyramide= glm::translate(modelPyramide, glm::vec3(0,0,0));
    

        if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS) z = z+0.05;
        if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) z = z-0.05;
        if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS) x = x-0.05;
        if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS) x = x+0.05;
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE);

         sky
        -> clear(0, 0, 0, 0)
        -> update("uniformView", viewMat)
        -> update("uniformModel", sky)
        -> update("uniformProjection", projMat)
        -> texture("tex",test)
        -> run();

        pass
        -> update("uniformView", viewMat)
        -> update("uniformModel",model )
        -> update("uniformProjection", projMat)
        -> update("color", glm::vec4(0,1,0,1))
        -> update("scale", size)
        -> update("luminance", lum)
        -> run();

for (int i = 2; i < 50; i=i+3){
  
    for (int j = -6; j < 7; j+=12){
 
  modelPyramide= glm::translate(modelPyramide, glm::vec3(j,1,50-i));

       passPyramide
        -> update("uniformView", viewMat)
        -> update("uniformModel",modelPyramide)
        -> update("uniformProjection", projMat)
        -> update("color", glm::vec4(1,0,0,1))
        -> update("scale", size)
        -> update("luminance", lum)
        -> run();
          modelPyramide = glm::mat4(1.0);

      }


}


    });
}